"""
Code generator: converts AST to Python code
"""
from typing import List
from .ast_nodes import *

class CodeGen:
    """Generates Python code from AST"""
    
    def __init__(self, program: Program):
        self.program = program
        self.out_lines: List[str] = []
        self.indent_level = 0
        self.func_names = {f.name for f in program.funcs}

    def emit(self, line: str = ""):
        """Emit a line of code with proper indentation"""
        self.out_lines.append("    " * self.indent_level + line)

    def generate(self) -> str:
        """Generate complete Python program"""
        # Module header
        self.emit("# Generated by simple compiler -> Python")
        self.emit("import sys")
        self.emit("")
        
        # Runtime helpers
        self.emit("# Runtime helpers")
        self.emit("def __input__():")
        self.indent_level += 1
        self.emit("return input()")
        self.indent_level -= 1
        self.emit("")
        
        # Generate all functions
        for f in self.program.funcs:
            self.gen_function(f)
            self.emit("")
        
        # Call main if it exists
        if "main" in self.func_names:
            self.emit("if __name__ == '__main__':")
            self.indent_level += 1
            self.emit("import sys")
            self.emit("sys.exit(main())")
            self.indent_level -= 1
        
        return "\n".join(self.out_lines)

    def gen_function(self, f: FuncDecl):
        """Generate Python function definition"""
        params = ", ".join(name for _, name in f.params)
        self.emit(f"def {f.name}({params}):")
        self.indent_level += 1
        
        for stmt in f.body:
            self.gen_stmt(stmt)
        
        # Ensure function has return
        if not any(isinstance(s, ReturnStmt) for s in f.body):
            self.emit("return None")
        
        self.indent_level -= 1

    def gen_stmt(self, s: Stmt):
        """Generate Python code for a statement"""
        if isinstance(s, VarDecl):
            for name, init in s.names:
                if init is None:
                    self.emit(f"{name} = None")
                else:
                    expr = self.gen_expr(init)
                    self.emit(f"{name} = {expr}")
            return
        
        if isinstance(s, ExprStmt):
            self.emit(self.gen_expr(s.expr))
            return
        
        if isinstance(s, IfStmt):
            cond = self.gen_expr(s.cond)
            self.emit(f"if {cond}:")
            self.indent_level += 1
            for st in s.then_block:
                self.gen_stmt(st)
            self.indent_level -= 1
            
            if s.else_block is not None:
                self.emit("else:")
                self.indent_level += 1
                for st in s.else_block:
                    self.gen_stmt(st)
                self.indent_level -= 1
            return
        
        if isinstance(s, WhileStmt):
            cond = self.gen_expr(s.cond)
            self.emit(f"while {cond}:")
            self.indent_level += 1
            for st in s.body:
                self.gen_stmt(st)
            self.indent_level -= 1
            return
        
        if isinstance(s, ForStmt):
            # Translate for to while
            if s.init:
                self.gen_stmt(s.init)
            
            cond_expr = self.gen_expr(s.cond) if s.cond else "True"
            self.emit(f"while {cond_expr}:")
            self.indent_level += 1
            
            for st in s.body:
                self.gen_stmt(st)
            
            if s.post:
                self.emit(self.gen_expr(s.post))
            
            self.indent_level -= 1
            return
        
        if isinstance(s, ReturnStmt):
            if s.expr is None:
                self.emit("return None")
            else:
                self.emit(f"return {self.gen_expr(s.expr)}")
            return
        
        raise NotImplementedError(f"Statement generation not implemented for {type(s)}")

    def gen_expr(self, e: Expr) -> str:
        """Generate Python expression string"""
        if isinstance(e, Literal):
            if isinstance(e.value, str):
                v = e.value.replace("\\", "\\\\").replace('"', '\\"')
                return f'"{v}"'
            if isinstance(e.value, bool):
                return "True" if e.value else "False"
            return repr(e.value)
        
        if isinstance(e, VarRef):
            return e.name
        
        if isinstance(e, AssignExpr):
            val = self.gen_expr(e.value)
            return f"({e.name} := {val})"
        
        if isinstance(e, BinaryExpr):
            left = self.gen_expr(e.left)
            right = self.gen_expr(e.right)
            op = e.op
            
            # Map logical operators
            if op == "&&":
                op = "and"
            if op == "||":
                op = "or"
            
            return f"({left} {op} {right})"
        
        if isinstance(e, UnaryExpr):
            expr = self.gen_expr(e.expr)
            op = e.op
            if op == "!":
                op = "not"
            return f"({op} {expr})"
        
        if isinstance(e, FuncCall):
            if e.name == "print":
                if len(e.args) == 0:
                    return "print()"
                args = ", ".join(self.gen_expr(a) for a in e.args)
                return f"print({args})"
            
            if e.name == "input":
                return "__input__()"
            
            args = ", ".join(self.gen_expr(a) for a in e.args)
            return f"{e.name}({args})"
        
        raise NotImplementedError(f"Expression generation not implemented for {type(e)}")